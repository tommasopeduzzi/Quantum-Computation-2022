# Week 11
## Parity Measurements in terms of Bell states
Until now we have thought of the parity measurement as telling us if the qubits are the same or not. This means that $$\begin{align*}
\Ket{00}, \Ket{11}\rightarrow 0 \\\\
\Ket{01}, \Ket{10}\rightarrow 1
\end{align*}$$
This is equivalent to thinking about in what superposition of bell states the two qubits are: $$\begin{align*}
\Ket{\phi⁺}, \Ket{\phi⁻}\rightarrow 0\\
\Ket{\psi⁺}, \Ket{\psi⁻} \rightarrow 1
\end{align*}$$Furthermore, we can see that doing a ZZ measurement (so a parity measurement in the Z basis for two qubits) is different to doing two Z measurements on the qubits, as it preseves the states. The same thing can be said about XX measurements and single qubit measurements in the X basis.

## The surface code
For the surface code, we think of the qubits as being in a latice, like in the diagram, where the qubits are the black dots. We perform X parity measurements in the squares formed by the qubits (we call these plaquettes) and on every vertex of the lines drawn between the qubits.
 ![[Surface code diagrams.png]]
We perform these plaquette syndromes on an auxillary qubit by doing CNOTs between every qubit on the plaquette and that auxillary qubit. We can think of this qubit as sitting in these plaquettes.
![[Surface code 1.png]]
To store classical information, such as a bit, plaquette syndromes are enough verify a state. We define a state as valid, if all plaquette syndromes are 0, and thus have even parity. This has the sideffects of having quite a lot of different valid states, that contain $1$s, but shouldn't be misinterpreted as a logical $1$, as it is still quite close to our original state. We can treat this exponential family of states as possible ways to store a $0$. This family can be generated by choosing a vertex and flipping all the bits around it and repeating this step.
![[Surface code 2.png]]
An interesting property this family is that any line going from the top qubits to the bottom qubits has even parity. This makes sense when you think about it, as you go in and out of a vertex, always has even parity, because of how we generate this family.
![[family of 0 states.png]]

This is the opposite case for states that encode a $1$: for any line in the family of states that encode a logical $\Ket{1}$, the parity for that line is odd. We generate the family by taking a line that goes through placketes and flipping all of the bits around that. 
![[generating 1 states.png]]
This leaves us with valid states, that have even parity on any line from the top to the bottom.

This means that distinguishing between the logical $\Ket{0}$ and $\Ket{1}$ state, is harder than when using the repetition code, which is good, because it leaves less space for errors to happen.

To measure a state in the Z-Basis, we measure every qubit in a line from top to bottom and look at the parity of that line. If it's odd, it's a 1; if it's even, it's a 0. So the operator that measures in the Z-basis is a tensor product of Z measurements.
Doing a logical Xs is really similar. We have to turn a state from one family of states to the other. This is done by performing an X on any line from the left to the right. Again, this operator is just a tensor product of single qubit Xs across any horizontal line of the surface code physical qubits. 
![[Errors in 1 and 0 surface code.png]]
We can see the effect of X-errors in the graphic above. An isolated error causes a pair of defects, while multiple errors next to the same plaquettes move the errors. We can use the same method as with the repetition code to find and correct these errors using the parities on the plaquettes and in a very similar way to the repetition code, bit more on that later. It also helps when we think of the edges as big plaquettes, to simplify the system. 
For a logical X-error to occur, we need X-errors to occur on an entire horizontal line of the code, which is easily mitigated, by just making the code bigger. In actuality, it is enough to stretch over half of the lattice, as our algorithm would consolidate the error miscorrect it. 
Using this arrangement we can correct bit flip errors, just like the repetition code.

To generalize this for any quantum state, we have to look at the vertex syndromes. The only difference between the plaquette syndromes, is that these lie on the vertices of the lattice and look at the parity of $\Ket{+}$ and $\Ket{-}$ states.
![[+ and - family of surface code encodings.png]]
The family of states thate encode a $\Ket{+}$ are all the valid states that have even parity from left to right, while the states that encode $\Ket{-}$ have odd parity from left to right. Again this leaves us with a exponential family of valid states that encode a + or a -. To generate the family of +s, we can just flip all of the qubits around plaquette(s), and for generating the family of -s we can just flip all the qubits along a vertical line, like in the image above. 
The logical Z on these states is like the Z measurement of the $\Ket{1}$ and $\Ket{0}$ states a tensor product of Zs from top to bottom and because measurements can be seen like logical operations (like we wrote in the first chapter of this week), this is the identical operator. 
The same holds for measuring in the X-basis, were the logical X operator from above can serve as our measurement.

Now let's look at the effects of phase flips:
![[general errors in surface codes.png]]
We can see that this is exactly the same as before, just that the syndromes are on the vertices, instead of the plaquettes. We can also see that a Y-flip causes both a phase and bit flip, which we can detect and correct.

It's quite obvious now, because the measurements and measurement operators of the two codes ($XXXX$ and $ZZZZ$) commute, that we can run these two codes together. This allows us to detect both bit flips (using the plaquette syndromes) and phase flips (using the vertex syndromes).  Because $XZ \sim Y$, we can also detect Y-errors.

Because the states that encode a specific logical Z state have to be eigenstates of the vertex operators and vice versa, the state encoding a 0 is a superposition of all valid states that encode a 0:
![[0 state superposition surface code.png]]

## Perform logical gates on surface codes
We saw before that we can easily perform X, Z and Y gates fault-tolerantly. 
In addition, we can perform Hadamards by effectively rotating the surface code by 90 degrees (swapping left-right to top-bottom and vice versa) and Hadmarding every physical qubit (from the Z to the X basis and vice versa).
A CNOT can also be quite easily performed, by looking at the parities and doing Xs accoringly. 
In general, all logical Cliffords can be performed. 
There's a method called *magic state distillation* where we use to our fault-tolerant cliffords, to clean up the non-fault-tolerant non-cliffords.

## Decoding & Correcting errors in the surface code
Decoding the surface code can be tricky, as hints can be caused by multiple errors, so we don't always know where exactly these errors happen. This isn't actually that big of a problem, because the things we use to deal with the errors either cancel them out in the ideal case or add up to the errors to create vertex operators, of which our states are eigenstates, so nothing happens.
Theres some hints that might make us think that we need to correct them in ways that actually cause logical errorsin combination with the physical errors, instead of just vertex operators. We can avoid this by checking if this is the case.

Like I mentioned earlier, we can use the same algorithm used in the repetition code to decode the information given to us by the syndromes. When taking into account the measurement errors on the syndromes, we can add a third dimension to the problem abd perform 3d minimum weight perfect matching:
![[minimum weight perfect matching surface code.png]]
To deal with accidental logical errors when correcting the physical errors, we can add "virtual" nodes at the top and the bottom and connect them with weight 0.

## Anyons!
The hints that are created can be looked at as particles in a two-dimensional universe, which is what surface codes essentially are. These are neither boson or fermions, like we are used to, but anyons. This is because they don't obey the same exchange statistics as bosons and fermions. This means that moving one around another causes the wave function to acquire a phase of -1, which doesn't happen with bosons or fermions.